---
categories: [intermediate, gitlab, remote]
image: ../static/gitlab-logo.png
abstract: |
  In this chapter, we will explore more advanced features of GitLab.
---

# GitLab: Advanced

::: {.callout-tip appearance="minimal"}
<h5>Learning Objectives</h5>
{{< include ../objectives/_objectives-gitlab-advanced.qmd >}}
:::

## Differences to GitHub

There are no major differences in basic Git operations (push, pull, clone) between GitLab and GitHub. 
However, there are some differences worth noting:

- **User Interface (UI):** 
The UI in GitLab looks different from GitHub, which is expected for two separate platforms. 
However, both UIs are user-friendly and designed for similar purposes.

- **Pull Requests vs. Merge Requests:** 
GitLab refers to pull requests as "merge requests" (MRs), which may be more intuitive since the purpose is to merge code from one branch or fork into another. 
GitHub sticks to the term "pull request".

- **Repositories naming:** 
GitHub simply refers to version-controlled projects as "repositories" or "repos." 
GitLab refers to them as "projects". 
Both terms fundamentally describe the same thing — a directory of files under version control.
GitLab's emphasis on "projects" can also imply its broader focus on project management.

- **More fine-grained permissions:**
GitLab offers more detailed access control with multiple user roles such as Guest, Reporter, Developer, Maintainer, and Owner. 
GitHub also provides roles, but GitLab's structure allows for greater control over permissions at both the group and project level.

- **CI/CD integration:** 
GitLab has built-in CI/CD (Continuous Integration and Continuous Deployment) features, whereas GitHub introduced its own GitHub Actions later. 
GitLab’s CI/CD setup is considered to be more comprehensive and customizable, with pipelines that can be configured more extensively. 

- **GitLab Pages:**
For static site hosting, GitLab Pages offers the ability to host sites directly from a repository. 
Unlike GitHub Pages, GitLab Pages for private repositories can require a login, which can be useful for more sensitive projects.

- **Security features:** 
GitLab places a heavier emphasis on security features. 
It includes built-in tools for vulnerability management, dependency scanning, and container scanning as part of its premium offerings.

- **Licensing and open source:** 
GitLab offers an open-source Community Edition (CE) in addition to its paid offerings, while GitHub is primarily a commercial product, though it has free tiers.
This makes GitLab more appealing to users who prefer open-source platforms.

## Forking on GitLab

Forking a repository on GitLab is similar to GitHub and allows you to create a personal copy of someone else's project under your GitLab account.
This copy includes all files, commit history, and branches, while maintaining a reference to the original repository.
Forking is ideal for contributing to projects without needing direct access to the original repository. 
You can make changes, create branches, and push modifications to your forked repository.
To contribute your changes back to the original project, you can submit a merge request, which is explained in more detail below.

### Creating a fork

1. **Navigate to the repository:**
First, go to the repository you want to fork on GitLab.
You can do this by searching for the repository or navigating to it directly if you have the URL.

2. **Click the Fork button:**
On the repository page, locate and click the "Fork" button, typically found in the upper-right corner of the page. 
This action creates an identical copy of the repository under your GitLab account.

3. **Choose your forking setting:**
After clicking the "Fork" button, you will be presented with the same options you have when creating a new GitLab repository, to configure your new fork. 

    - Start by deciding on the **Project Name**.
    By default, the name of the forked project will be the same as the original repository, but you can change it if desired. 
    - The **Project Slug** will be automatically generated based on the project name, but you can also customize this URL-friendly version if needed. 
    - Optionally, you can add a **Project Description** to help others understand the purpose of your forked repository.
    - Next, set the **Visibility Level** of your forked project.
    You have three options: Private, Internal, or Public [details here](#visibility-levels).
    - Finally, select the **Namespace** under which you want to fork the repository.
    This could be your personal namespace or any group or organization you belong to.

After configuring these settings, click the "Fork project" button to complete the process.
Your forked repository will be created under your specified namespace with the chosen settings.

![Screenshot of the GitLab forking options.](../static/gitlab_fork.png){#fig-forking_gitlab}

## Pull Requests (Merge Requests)

In GitLab, **pull requests are referred to as merge requests (MRs)**. 
They serve the same purpose as pull requests in GitHub, allowing for code review and integration into a project's codebase.

There are more ways to create a merge request on GitLab than the two explained below, you can check out the [GitLab documentation](https://docs.gitlab.com/ee/user/project/merge_requests/creating_merge_requests.html?tab=Branch+only) for more info.

### Creating a merge request from a forked repository

To create a merge request after forking a repository and making changes, follow these steps:

1. **Navigate to your forked repository**:
Go to your forked repository on GitLab and make sure you are on the branch that contains the changes you want to propose.

2. **Open a new merge request**:
Click on the "Merge Requests" tab in the sidebar, then click on the "New merge request" button.

3. **Choose branches**:
In the merge request interface, select the branch you made changes to in your fork (the "compare" branch) and the original repository's branch where you want to propose your changes (the "base" branch).

4. **Review changes**:
Review the changes that will be included in the merge request.

5. **Create merge request**:
Click on the "Create merge request" button.
Provide a meaningful title for your merge request and a description explaining the changes you made.

6. **Submit the merge request**:
Submit the merge request. 
The owner of the original repository can now review and approve the changes, merging your fork's branch into their repository.

### Creating a merge request from a branch within a repository

In this scenario, contributors work directly within the original repository, creating a new branch for their changes. 
After completing the changes in the branch, they create a merge request from that branch to the repository's default branch (typically `main` or `master`). 
The workflow is similar to that of opening a merge request from a forked repository.
Follow the same steps as described above for opening a new merge request, choosing branches, reviewing changes, creating, and submitting the merge request.

## Templates

Project templates in GitLab provide a convenient way to create new projects with predefined files, directories, and configurations. 
Instead of starting a new project from scratch, you can use a project template that includes the necessary setup for specific types of projects, following best practices and common standards. 

To use a project template in GitLab, navigate to the "New project" page. 
Here, you will find various templates available, ranging from simple project setups to complex configurations, for e.g., web applications or mobile apps.
Select the desired template, and you will be prompted to provide a name for your new project, an optional description, and select whether the repository should be public or private.
GitLab then creates a new project based on the chosen template, complete with the predefined structure and files.
If you are member of a group, you can also see the templates which were created in the group.

![Screenshot of project templates in GitLab.](../static/gitlab_template.png){#fig-forking_gitlab}

## Project settings

The project settings in GitLab provide comprehensive control over your project's configuration, allowing you to customize various aspects to suit your workflow and security needs.
These settings include:

In **General Settings**, you can manage basic information like the project name and description.
You can also enable or disable features such as issues, merge requests, wiki, and snippets, and archive the project if it's no longer active. 
In the subsection **Visibility, project features and permissions**, you can configure who can see your project and its contents.
This section allows you to enable or disable project features and set different [visibility](#visibility-levels) and [permission levels](#permission-levels-and-roles) to control user capabilities.

The **Repository Settings** section includes options for protecting branches and tags to prevent unauthorized changes, specifying who can merge or push. 
You can enforce push rules on commit messages, branch names, and file names for consistency, and monitor and manage repository size to ensure optimal performance.

In **Merge Request Settings**, you can set up merge request preferences, including choosing the merge method (merge commit, squash and merge, or rebase and merge).
You can also require conditions like approvals or passing CI/CD pipelines before merging and define who must approve merge requests.

For more detailed information on configuring repository settings, visit the [GitLab documentation](https://docs.gitlab.com/ee/user/project/settings/)

![Screenshot of repository settings in GitLab ](../static/gitlab_repo_settings.png){#fig-repo_settings_gitlab}

## GitLab specific features

GitLab offers several unique features and advanced functionalities that can be beneficial for managing large-scale projects and teams.
GitLab especially focuses on project management and security features, which are more comprehensive than the ones from GitHub.
You can check out the [GitLab documentation](https://about.gitlab.com/why-gitlab/) for more info.

### GitLab groups

GitLab groups allow you to manage multiple related projects and users in a centralized structure, simplifying collaboration and access control.
Groups enable you to set permissions, communicate with all group members, and manage projects efficiently. 
If someone has access to the group, they automatically get access to all projects within that group.
For larger organizations, you can create subgroups, which inherit permissions from their parent groups.
Additionally, you can implement consistent project templates and standards across all projects within the group.
GitLab also offers visibility and reporting features that help track progress and performance across multiple projects.  

To create a group, go to the left sidebar, select "Create new" and "New group".
Enter the group name, URL path, and select the visibility level.
Optionally, you can personalize your GitLab experience by selecting your role, specifying the purpose of the group, and inviting members.
For more detailed information about creating and managing groups, refer to the [GitLab documentation on groups](https://docs.gitlab.com/ee/user/group/).

### Visibility levels

Who can find a project or group is managed by the visibility levels.
They can be set to private, internal or public.
A **private** project or group can only be accessed by the owner and collaborators who've been specifically invited.
An **internal** project or group, anyone who is logged into GitLab can see.
This is especially useful if your organization runs a self-hosted GitLab site, which in this case means only people who can log into this specific GitLab can view the internal projects or groups.
This can be a great way to e.g. share a best practices wiki or frequently needed forms with the entire organization, without having to manage everyone's permission levels.
A **public project**, anyone on the internet can find, even if it's on a self-hosted GitLab.

### Permission levels and roles

GitLab allows for a very fine-grained approach to managing permission levels.
Either use the default permission levels or customize them for each user.
If the user is part of the project's group and the project, the higher permission level is applied.

The default roles, ranked from most to least permissions:  
1. **Owner**: Full control.  
2. **Maintainer**:  Almost full control, but can't change project's visibility or delete it.  
3. **Developer**: Push code and create merge requests.  
4. **Reporter**: View project, comment on issues and merge request and generate reports.  
5. **Planner**: Create, comment and review issues.  
6. **Guest**: Very restricted. 
View projects and create issues.

### Issues

Generally, issues serve the same function on GitLab as on GitHub.
However, there are some very nice features, that are either not available on GitHub or simply not as well integrated in the workflow as on GitLab.
First of all, it is easy to assign **due dates** to issues, which helps to keep track of a project's time line and what needs to be prioritized.
Secondly, there is the option to make issues **confidential**, so they can only be seen by group members or the person who created them.
This is especially helpful in public projects, where you might not want everyone on the internet to be able to follow your discussions on a bug or don't want to expose a security flaw you are currently trying to fix.

#### Issue boards

GitLab makes it easy to assign and manage issues using issue boards, see @fig-issue_board.
Especially in larger groups or for longterm projects, this feature can help keep track of who is doing what and until when issues should be completed.
Even if working by oneself, it can be helpful to have this visualization of what has already been accomplished and easily see what needs to be worked on next.

![Screenshot of issue boards on GitLab ](../static/issue_board.png){#fig-issue_board}

### Workflow and project management

The different [visibility](#creating-a-fork) and [permission levels](#permission-levels-and-roles) allow for a workflow across the group that ensures everyone knows what the others are working on and the projects remain available.
When team members are changing, transferring project ownership can be a hassle and minor projects are prone to be forgotten.

The following sketches an exemplary workflow for your project as a part of a research group.  
At the start, only you are working on the project, and it is set to the visibility level private.
As it is part of your research groups private GitLab group, everyone in the group can see it and has a Guest or Reporter role.
They can point out problems or add new ideas via creating a new issue.
Your collaborators, that are part of your group or external ones, are assigned a Developer or Maintainer role and can push code and create merge requests.
You manage the different issues and assign due dates and collaborators to them.
On the issue board, you can easily see what has already been tackled and what your collaborators and you have already addressed.
The principal investigator has a Maintainer or Owner role in the project and thus can ensure that a project remains available, even if the people in the research group change.
Once the project is finished and a related paper is published, the visibility level is set to public and it can be accessed by anyone on the internet.

## Acknowledgements

```{r}
#| eval: true
#| echo: false
#| message: false
#| warning: false
#| output: asis
bibtexkeys = c("chacon2014", "community2022", "gitlab2024")
knitr::kable(ref_table(bibtexkeys), format = "markdown")
```
