---
image: ../static/
categories: [advanced]
abstract: |
  How does Git work under the hood?
engine: knitr
execute:
  eval: false
---

# Git internals
 
::: {.callout-tip appearance="minimal"}
<h5>Learning Objectives</h5>
{{< include ../objectives/_objectives-internals.qmd >}}
:::

## Introduction

Understanding the internal work of Git provides significant benefits for anyone managing projects with version control.
This knowledge can e.g. lead to better control over project changes and more effective troubleshooting when issues arise. 
By learning about the inner workings of Git, particularly the `.git` folder, you can gain a deeper understanding of how Git tracks changes and maintains the history of your work. 
This understanding is not just for developers.
Everybody can use these insights to manage their projects more effectively.

The `.git` folder is the "heart" of any Git repository. 
It contains all the metadata and object data that Git uses to manage and track your project versions. 
By unterstanding its structure and contents, you can better understand how Git operate. 
This chapter aims to clearly explain what is going on in the `.git` folder, making its structure and function more clear.

Git's architecture is built around the concept of snapshots and content addressability. I
nstead of storing differences between file versions, Git captures the state of the entire repository at each commit. 
These snapshots are stored as objects in the `.git` directory, each identified by a unique SHA-1 `hash`. 
This design ensures that every object is fixed and verifiable, allowing Git to quickly and reliably reconstruct the history of any project.

By the end of this chapter, you will have a clearer understanding of how Git manages your project's history, enabling you to use Git more effectively and troubleshoot any issues with confidence.

## `.git` folder

The `.git` folder is the basis of any Git repository.
When you initialize a Git repository using `git init`, this hidden folder is created inside your project. 
It contains all the metadata and object data that Git needs to manage and track your project's versions.
This data is stored in files and folders that you can normally open and view.
If you use `ls -a` in your `.git` folder to show all files and folders in it, you should normally get the output:

```{zsh, filename="Output"}
config
description
HEAD
hooks/
info/
objects/
refs/
```

This chapter is going to explain all files and folders of these down below.

### `config` file

The config file within the .git directory is where Git stores 
configuration settings (e.g. name, email...) specific to that repository, that are not set globally.
The `config` file is organized in sections, each containing related configuration variables.
For instance:

```
[user]: Contains the user's name and email.
[core]: General settings, such as file modes.
[remote "origin"]: Details about the default remote repository.

```

Instead of using `git config` you could also edit this file directly to make changes.

### `description` file

The `description` file within the `.git` directory plays a minor but specific role in the context of Git repositories.
The `description` file is most commonly used in bare repositories.
In bare repositories, Git web interfaces and hosting services use the content of this file to display information about the repository to users.
It should contain a contain a simple, plain-text description of the repository.

A bare repository is a special repository without a working directory, meaning you can not directly edit files in this repository as it *only* contains the `.git` folder.
This type of repository can be created using `git init --bare` or `git clone --bare`.
It is typically used in software devolopments for collaboration.

### `HEAD` file

The `HEAD` file in the `.git` folder points to the latest commit on the current branch you are working on. 
Typically, `HEAD` contains a reference to the branch name, such as `ref: refs/heads/main`. 
This means `HEAD` is pointing to the `main` branch.
When you checkout a specific commit rather than a branch, `HEAD` is said to be in a "detached" state, pointing directly to that commit’s hash.

You view the content of your own `HEAD` file simply navigate in your `.git` folder using `cd .git` and then use .... on Windows/`open HEAD` on Mac OS.
This chapter is going to explain some of the file/folder´s content in detail down below.

### `hooks` folder

The `hooks` folder allows you to automate various tasks in your Git workflow. 
Git hooks are scripts that are executed by specific events in the Git lifecycle, such as committing changes or pushing to a repository. 
To create a hook you have to write a script inside a file in `.git/hooks`.
Git uses predefined names for hook scripts. 
You cannot choose arbitrary names; instead, you must use the names that Git recognizes for the various hooks. 
Git hooks are typically written in bash, but can be in any programming language, provided the scripts are executable on your system. 

::: {.callout-tip title="Example Hook script " collapse="false"}

**Commit message hook**:

This hook would run after a commit message is entered but before the commit is finalized.
To ensure that Git recognizes it, you have to place it inside `.git/hooks` and name it: `commit-msg` (without any file ending)
Hooks that run before a a commit message is input, can be useful for enforcing commit message standards.

**Example:**

```
#!/bin/sh
COMMIT_MSG_FILE=$1
MSG=$(cat $COMMIT_MSG_FILE)
if ! echo "$MSG" | grep -q "Reviewed"
then
  echo "Commit message must contain the word 'Reviewed'"
  exit 1
fi

```

The script ensures commit messages include the word "Reviewed".
This could be useful in a workflow where commits need to be reviewed by another team member before they are accepted.
It reads the commit message from a file provided as an argument and checks if the commit message contains the word "Reviewed".
If the word is not found, it prints an error message and prevents the commit.


There are many more ways to use hooks (e.g. pre-commit, pre-push etc..). 

You can check out the [Git documentation about hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) for more information.
:::

### `info` folder

The `info` folder within the `.git` directory contains information and configurations which manages it´s behavior.
The two important files in this folder are the `exclude` file and the `refs` file.

#### `exclude` file

The `exclude` file allows you to specify file patterns to be ignored by Git, similar to a `.gitignore` file.
The file is not intended to be committed to the repository, since it is located in the `.git` folder, which is saved locally in your system. 
It is used to define ignore patterns that are specific to your local repository environment.
The patterns defined in the `exclude` file are not shared with other collaborators, making it useful for ignoring files that are specific to your local development environment and should not affect others working on the same repository.
To edit the `exclude` file, navigate to the info directory within your `.git` folder using `cd .git/info` and then open the exclude file with a text editor of your choice.
The exclude file syntax follows the same rules as `.gitignore` files, enabling you to specify patterns for files and directories that Git should ignore.

#### `refs` file

The `refs` file within the info folder provides references to commits in the repository. 
This file is part of Git's internal mechanism for keeping track of different branches and tags within the repository. 
It contains pointers to the commit objects, helping Git manage the repository’s history and branching structure.

E.g., in the repository of this book the `refs` file looks like this:

```
ad24067d74f0196bb2c07cb6389220d6c9217737	refs/heads/GUI
a7049cab0d3092be2bcb16042ac782acd57e969c	refs/heads/README.md
89a9f0a57297f5febe31b2b83f535f5717e735e5	refs/heads/branches_ss24
334d7149901dff1cb44829d9017a9504eaf8c62d	refs/heads/chapter/git_internals
460601f061240a2b536a7251aab1fd18fb816545	refs/heads/cheatsheet
37904c94d20e843e12aac118a06a7a4d48ee71c2	refs/heads/cheatsheet_branches
c7781e284971ea8e2c61c8366ed323c9d9a7d176	refs/heads/cli
a7d83248280c708d14ce27ad840eaeaaa0796ff0	refs/heads/commonmistakes
ed85342fef5e40d991f8dd67ef0a63f972c631f8	refs/heads/content/branches
d01f7626e9a67a57778002b4d028b0c52b6cc10b	refs/heads/content/first_steps
6c421e034c3354fa07f9e13c53df8e89bfc87cb6	refs/heads/content/setup
d5a6080b59cfc924fb2c11b69941ecad3bd07437	refs/heads/contributing
a5cd2f53e1ddfc467d280a766453092dcd898ce7	refs/heads/draft
c662cdf6e838ab86f59483c12b68ba24d6598412	refs/heads/editexisting
03156e5568ee8b1db4ccc67ee7d0116a17e34b48	refs/heads/editpreface
```
To view or edit the refs file, navigate to the info directory within your `.git` folder using `cd .git/info` and open the refs file with a text editor. 
It is not recommended that you edit this file by hand, as incorrect modifications can lead to issues with the repository’s references and history.

### `objects` folder

The objects folder within the `.git` directory is a fundamental part of Git’s internal storage system.
This folder contains all the objects that Git uses to track the history and state of your repository. 
When you first explore the objects folder, you will see a series of subfolders, each named with two hexadecimal characters (e.g.,`d6`, `e9`, `fa`)



### `refs` folder

### `logs` folder

## How Git stores data

### Hashes

### Blobs

### Commits

### Pack files

### Garbage Collection

## Practical Tips

### Inspect Objects

### Repairing `.git` folder

### Exploring `.git` folder

```{r}
#| eval: true
#| echo: false
#| message: false
#| warning: false
#| output: asis
bibtexkeys = c("GitHub2023", "chacon2014", "community2022", "amin2023")
knitr::kable(ref_table(bibtexkeys), format = "markdown")
```

## Cheatsheet

```{r}
#| eval: true
#| echo: false
#| message: false
#| warning: false
knitr::kable(table_cheatsheet(name = "branches"), format = "markdown", row.names = FALSE)
