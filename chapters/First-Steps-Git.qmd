---
title: "First Steps with Git"
engine: knitr
execute:
  eval: false
  title-block-style: none
author: ""
---

::: callout-note
### Overview

{{< fa clock >}} Duration:  min
:::

# Learning objectives

In this Chapter your will learn basic Git operations including:

-   Initializing a Git Repository
-   Staging and Commiting Changes
-   Exploring the commit history
-   Comparing Versions

# Initializing a Folder as a Git Repository {{< fa folder-closed >}}

To create your first Git Repository you need a folder to initialize. In the chapter [Command Line Basics](command-line.qmd) it is explained how to create an empty folder using the command line. You can also just create one the regular way.

Navigate, using the Terminal, to the folder which you want to initialze as a Git repository. 
You can use the `cd` command to change directories. Once you are in the desired directory, run the `git init` command to initialize the folder as a Git repository. 

```{bash}
git init
```

should get the following output.

```{bash}
Initialized empty Git repository in /Users/.../
```

Congratulations on successfully initializing your first Git repository! {{< fa champagne-glasses >}} 

Git is now able to track your changes in this Folder. You only need to user `git init` once per folder. 


# Status, Staging and committing {{< fa file-export >}}

## Status

After initializing Git is now able to record the changes of your file, but it will not do so automatically.

You can use `git status` to visualize this.

```{bash}
git status
```

You should receive an output like this

```{bash}
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	example.txt
```

As you see Git is not yet tracking your file. 

## Staging
You can use  **git add** to put files in the "staging area".
The staging area serves as a space where you can gather changes that you intend to commit soon.
When working on a project, you might have made multiple changes for different purposes. 
To organize and group these changes into meaningful commits, you can place the relevant files in the staging area. 
The staging area acts as a bridge between your modified files and the next commit, allowing you to carefully select and include specific changes in your upcoming commit.

```{bash}
git add example.txt
```

If you use **git status** again, your file(s) should now show up under "changes to be commited".

```{bash}
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   example.txt
```

This means your change in this folder, in this case adding a file, is now **staged**.



## Committing

Now that your changes are staged, you are ready to create a commit. To create a commit, use the `git commit` command followed by the flag `-m` and a commit message **in qoutes** that describes the changes you made.
The commit message should be short yet informative, providing enough detail to understand the purpose of the commit. 
If you just use `git commit` without adding a commit massage, the editor of [your choosing](Setting up Git.qmd), opens up and lets you type in a commit message.

```{bash}
git commit -m "Add example.txt file"
```

```{bash}
[main (root-commit) e9ea807] adding txt file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 example.txt
```

Congratulations! You have successfully created your first commit in the Git repository. 
Commits are the core elements of version control, they allow you to track the history of your project and easily revert changes if needed.

You can use the same worklow of **git add** and **git commit** for every file you add or make changes in.

### Logging Commits

To look at your past commits you can use the **git log** command.

```{bash}
git log
```

```{bash}
commit e9ea80781ceed7cc3d6bff0c7bfa71f320ec1f60 (HEAD -> main)
Author: Example <beispiel@example.de>
Date:   Thu Jun 29 12:23:53 2023 +0200

    adding txt file
```

**git log** is useful because it provides a clear and organized view of a repository's commit history. 
It allows you to track the evolution of a project over time by displaying detailed information about each commit, including changes made, authors, and timestamps. 
The command can help identifying the source of bugs or issues by pinpointing the commit that introduced them. 
It can aid collaboration and code review by showing who made specific changes to the codebase.


### Comparing Versions
Another very handy feature is the **git diff** command.
It allows you to compare two different versions of your file. 
By default it shows you any uncommited changes since the last commit. 
Explore this by pasting this text in your .txt file
```
Lorem ipsum dolor sit amet, consectetur adipisici elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. 
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. 
Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```
and look at the change using


```{bash}
git diff
```
```{bash}
+++ b/example.txt
@@ -0,0 +1 @@
+Lorem ipsum dolor sit amet, consectetur adipisici elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\ No newline at end of file
```


# Exercise {{< fa list-check >}} 
- Stage and commit the change (added Text) with a meaningful commit message
- look at your commit using the **git log** command


# Sources 
https://happygitwithr.com/ 

https://the-turing-way.netlify.app/reproducible-research/vcs/vcs-git.html
https://milesmcbain.github.io/git_4_sci/using-a-git-repository.html
